#!/usr/bin/python3

"""\
This script takes a graph as input and solves for the split points using each
of the available algorithms.

Usage: solver.py -i <graph>

Dependencies:
  <graph> : The .graph file generated by extract.py
"""

import argparse
import signal
import timeit

from src.alg.algorithm import Algorithm
from src.alg.brute_force_algorithm import BruteForceAlgorithm
from src.alg.dp_algorithm import DPAlgorithm
from src.alg.dws_algorithm import DWSAlgorithm
from src.alg.ilp_algorithm import ILPAlgorithm
from src.alg.naive_algorithm import NaiveAlgorithm
from src.alg.no_algorithm import NoSplitAlgorithm
from src.alg.random_algorithm import RandomAlgorithm
from src.graph import Graph

def handler(signum, frame):
    raise TimeoutError()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "-i",
            "--input",
            help="Input file name",
            type=str,
            required=True
        )
    args = parser.parse_args()

    g = Graph()
    g.read_from_csv(args.input)
    g.find_branches()
    algs = [
        NoSplitAlgorithm(g, 3),
        DWSAlgorithm(g, 3),
        RandomAlgorithm(g, 3),
        NaiveAlgorithm(g, 3),
        DPAlgorithm(g, 3),
        BruteForceAlgorithm(g, 3),
        ILPAlgorithm(g, 3)
    ]


    # print(f"{f'Algorithm':<25} {f'Analytical WCET':<25} {'Algorithm Runtime (s)'}")
    wcets = []
    runtimes = []
    a: Algorithm
    for a in algs:
        # print(f"{a.name():<25} ", end="")
        signal.signal(signal.SIGALRM, handler)
        signal.alarm(10)
        start = timeit.default_timer()
        try:
            sp = a.solve()
        except TimeoutError:
            sp = [-1]
        end = timeit.default_timer()
        wcet = a.wcet(splits=sp)
        wcets.append(str(wcet))
        runtimes.append(str(end-start))
        # print(f"{wcet:<25} {end-start:.9f}")
    csv_row = f"{args.input},{','.join(wcets)},{','.join(runtimes)}\n"
    print(csv_row)

    with open("solver-data.csv", mode="a+") as fo:
        fo.write(csv_row)
