#!/usr/bin/python3.12

"""\
This script parses the gem5 execution log and HIP assembly file to extract the
CFG of a benchmark.

Usage: python3.12 extract.py -i <asm> [-l <log> -u -r -d -p]

Dependencies:
  <asm> : Generated by the HIP compiler using the -save-temps flag
  <log> : Generated by gem5 using the IPT and PWSDebug debug flags

Outputs:
  <input>-XXX.csv
  <input>-XXX.png (Optional with -p flag)
  <input>-XXX.s   (Optional with -d flag)
"""

from pathlib import Path
import argparse
import re

from src import pattern
from src.graph import Graph

class Extractor():
    """
    This class extracts control-flow information from the source assembly file
    and optionally from the gem5 log file to extract the execution times for
    each basic block
    """
    def __init__(self, input_file: str) -> None:
        self.input: str = input_file
        self.graphs: list[Graph] = []

    def read_basic_block_number(self, line: str) -> int:
        """
        Extract the basic block number from the line that defines the basic
        block label
        """
        assert re.search(pattern.LABEL_BB, line)
        numbers_in_line = [int(x) for x in re.findall(r'\d+', line)]
        if line.startswith(';'):
            return numbers_in_line[0]
        return numbers_in_line[1]

    def read_branch_target(self, line: str) -> int:
        """
        Extract the basic block number from the branch instruction target
        """
        assert re.search(pattern.INST_BRANCH_COND, line) or \
            re.search(pattern.INST_BRANCH_UNCOND, line)
        numbers_in_line = [int(x) for x in re.findall(r'\d+', line)]
        if re.search(pattern.INST_BRANCH_COND_SCC, line):
            return numbers_in_line[2]
        return numbers_in_line[1]

    def is_inst_double_word(self, line: str) -> bool:
        """
        Determine whether an instruction should be 64 bits
        """
        return bool(
            re.search(pattern.INST_MEM_SCALAR, line) or \
            re.search(pattern.INST_MEM_LDS, line) or \
            re.search(pattern.INST_MEM_VECTOR, line) or \
            re.search(pattern.INST_DOUBLE_WORD_LONG_IMM, line) or \
            re.search(pattern.INST_DOUBLE_WORD_MISC, line) or \
            re.search(pattern.INST_DOUBLE_WORD_ALU, line)
        )

    def parse_asm(self) -> None:
        """
        Open the assembly file generated with the -save-temps flag and generate
        a CFG of the basic blocks and edges between them
        """
        current_bb_number: int = 0
        pc: int = 0
        # If we encounter an unconditional branch instruction at the end of a
        # basic block, then we shouldn't insert an edge to the next basic block
        previous_inst_uncond_branch: bool = False
        g = Graph()
        with open(self.input, encoding="utf-8") as fi:
            for line in fi:
                line = line.strip()
                if re.search(pattern.LABEL_BB, line):
                    if re.search(pattern.KERNEL_START, line):
                        g.insert_basic_block(0)
                    elif previous_inst_uncond_branch:
                        g.insert_basic_block(
                            self.read_basic_block_number(line)
                        )
                    else:
                        g.insert_edge(
                            src=current_bb_number,
                            dst=self.read_basic_block_number(line)
                        )
                    current_bb_number = self.read_basic_block_number(line)
                    previous_inst_uncond_branch = False
                elif re.search(pattern.INST, line):
                    previous_inst_uncond_branch = False
                    if re.search(pattern.INST_BRANCH_COND, line):
                        g.insert_edge(
                            src=current_bb_number,
                            dst=self.read_branch_target(line)
                        )
                    elif re.search(pattern.INST_BRANCH_UNCOND, line):
                        g.insert_edge(
                            src=current_bb_number,
                            dst=self.read_branch_target(line)
                        )
                        previous_inst_uncond_branch = True
                    g.insert_instruction(
                        inst=line,
                        pc=pc,
                        bb=current_bb_number
                    )
                    if self.is_inst_double_word(line):
                        pc += 8
                    else:
                        pc += 4
                    if re.search(pattern.KERNEL_END, line):
                        pc = 0
                        self.graphs.append(g)
                        g = Graph()

    def parse_log(
        self,
        log_file: str
    ) -> None:
        """
        Get execution times from gem5 log file and incorporate them as weights
        into the CFG
        """
        with open(log_file, encoding="utf-8") as fi:
            for line in fi:
                if re.search(pattern.IPT_EDGE, line):
                    kernel_id, start, end, count, latency = \
                        [int(x) for x in re.findall(r'\d+', line)[-5:]]

                    assert kernel_id < len(self.graphs)
                    g = self.graphs[kernel_id]
                    g.update_latency(
                        start_pc=start,
                        end_pc=end,
                        latency=latency
                    )
                    edge = (
                        g.next_instruction_basic_block(start),
                        g.next_instruction_basic_block(end)
                    )
                    if start == end: # self-loop
                        edge = (
                            g.pc_map[start],
                            g.pc_map[end]
                        )
                    # if edge in g.loopback_edges():
                    g.loop_bounds[edge] = count

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--input",
        help="Input disassembly file name, used to construct a CFG for each "
            "kernel",
        type=str,
        required=True
    )
    parser.add_argument(
        "-l",
        "--log",
        help="gem5 log file name, used to extract runtime loop iteration "
            "counts and basic block execution times",
        type=str,
        default=''
    )
    parser.add_argument(
        "-u",
        "--unroll",
        help="Unroll any loops in the graph",
        action="store_true"
    )
    parser.add_argument(
        "-r",
        "--renumber",
        help="Renumber basic blocks in topological order",
        action="store_true"
    )
    parser.add_argument(
        "-p",
        "--plot",
        help="Plot the CFGs and output a PNG file for each kernel",
        action="store_true"
    )
    parser.add_argument(
        "-d",
        "--disassemble",
        help="Save the disassembly with PCs in separate files per kernel",
        action="store_true"
    )
    args = parser.parse_args()

    e = Extractor(args.input)
    e.parse_asm()
    if len(args.log):
        e.parse_log(args.log)
    for g in e.graphs:
        if args.unroll:
            g.unroll_loops()
            # We need to separate nodes that act as both branch nodes and get
            # BSB and reconvergence information for separating branch nodes and
            # reconvergence points
            g.find_branches()
        g.separate_branches_from_joins()
        if args.renumber:
            g.renumber_basic_blocks()
    path = Path(args.input)
    for i, graph in enumerate(e.graphs):
        file_name = f"{path.parent}/{path.stem}-{i:03}"
        # Renumbering could have messed up the BSB and reconvergence
        # information, so we repeat the process
        if args.unroll and args.renumber:
            graph.find_branches()
        if args.disassemble:
            graph.write_disassembly(file_name=f"{file_name}-anno.s")
        graph.write_to_csv(file_name=f"{file_name}.csv")
        if args.plot:
            graph.plot(file_name=f"{file_name}.png")
