#!/usr/bin/python3

"""\
This script parses the gem5 execution log and HIP assembly file to extract the
CFG of a benchmark.

Usage: extract.py -i <input>

Dependencies:
  <input>.s   : Generated by the HIP compiler using the -save-temps flag
  <input>.log : Generated by gem5 using the WavefrontSplit and IPT debug flags

Output: <input>.graph
"""

import argparse
import glob
import re

from graph import *

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "-i",
            "--input",
            help="Input file name",
            type=str,
            required=True
        )
    args = parser.parse_args()

    insts = {}
    pcs = {}
    edges = {}
    # If we want to process multiple log files, put them in input*.log
    for log_file in glob.glob(f"data/{args.input}*.log"):
        lines = []
        with open(log_file) as f:
            lines = f.readlines()

        first_pc = -1
        for line in lines:
            # Extract pc and inst from line, e.g.
            #
            # 78278037000: system.cpu3.CUs0.wavefronts00: CU0: WF[0][0]: wave[0]
            # Executing inst: s_and_b32 s0, s6, 1 (pc: 0x7fff5e780000; seqNum: 1)
            #
            # Subtract starting PC to get relative address
            if "Executing inst" in line:
                pc = int(line.partition("pc: 0x")[2].partition(';')[0], 16)
                if first_pc == -1:
                    first_pc = pc
                pc = pc - first_pc
                inst = line.partition("Executing inst: ")[2].partition(' ')[0]
                assert inst.startswith("s_") or inst.startswith("v_") or inst.startswith("flat_") or inst.startswith("ds_")
                if pc in insts:
                    assert insts[pc] == inst
                insts[pc] = inst

        with open(log_file) as f:
            lines = f.readlines()

        for line in lines:
            if "EDGE" in line:
                values = line.split('|')
                if int(values[1].strip(), 16) == 0:
                    continue
                start = int(values[1].strip(), 16) - first_pc
                end = int(values[2].strip(), 16) - first_pc
                latency = int(values[3].strip())

                if start not in edges:
                    edges[start] = {}
                if end not in edges[start]:
                    edges[start][end] = latency
                else:
                    edges[start][end] = max(latency, edges[start][end])

    bb = {}
    pc_bbs = {}
    cfgs = []
    cfg = {}
    lines = []
    with open(f"data/{args.input}.s") as f:
        lines = f.readlines()

    skip = True # skip extra lines before BB0 and after s_endpgm
    block = 0
    inst_idx = 0
    pcs = sorted(insts.keys())
    branch_insts = ["s_cbranch", "s_branch"]
    branch = False
    iterations = {}

    for line in lines:
        line = line.lstrip()
        if line.startswith("; Iterations ("):
            # get number between parentheses
            iterations[block+1] = int(line[line.find("(")+1:line.find(")")])
        if "; %bb.0:" in line:
            bb[0] = []
            cfg[0] = []
            skip = False
            continue
        if skip:
            continue
        if line.lstrip().startswith("s_") or line.lstrip().startswith("v_") or line.lstrip().startswith("flat_"):
            bb[block].append(pcs[inst_idx])
            pc_bbs[pcs[inst_idx]] = block
            inst_idx += 1
        if any(inst in line for inst in branch_insts):
        # If we encounter a cbranch
        # If the target doesn't exist, add the node
        # Connect current node to branch target
            target = int(re.findall(r'\d+', line.split()[1])[1])
            if target not in cfg.keys():
                cfg[target] = []
                bb[target] = []
            cfg[block].append(target)
            if "s_branch" in line:
                branch = True
        elif "BB" in line or "bb" in line:
        # If we encounter a BB, create a new node
        # If the current node is another BB, create a direct link from the previous one
        # Set the new node as the current BB
            numbering_index = 1
            if line.lstrip().startswith(';'):
                numbering_index = 0

            line_nums = re.findall(r'\d+', line)

            target = int(line_nums[numbering_index])

            first_node = len(cfg) == 0

            if target not in cfg.keys():
                cfg[target] = []
                bb[target] = []

            if not first_node and not branch:
                cfg[block].append(target)
            branch = False
            block = target
            instructions = 0
        elif "s_endpgm" in line:
        # An endpgm instruction ends the kernel
            target = block + 1
            cfg[block].append(target)
            block = 0
            target = 0
            cfgs.append(cfg)
            cfg = {}
            skip = True

    def next_pc(pc: int, pcs: List[int]) -> int:
        if pcs.index(pc) == len(pcs)-1:
            return 0
        return pcs[pcs.index(pc) + 1]

    def prev_pc(pc: int, pcs: List[int]) -> int:
        if pcs.index(pc) == 0:
            return len(pcs)-1
        return pcs[pcs.index(pc) - 1]

    weights = dict.fromkeys(bb, 0)
    for u in sorted(edges.keys()):
        for v in sorted(edges[u].keys()):
            # assert u in pc_bbs and v in pc_bbs
            if u in pc_bbs and v in pc_bbs:
                # pc might be last one in BB, so we advance to the next BB in that case
                bb_u = pc_bbs[u] #if pc_bbs[next_pc(u, pcs)] == pc_bbs[u] else pc_bbs[next_pc(u, pcs)]
                bb_v = pc_bbs[v] #if pc_bbs[next_pc(v, pcs)] == pc_bbs[v] else pc_bbs[next_pc(v, pcs)]
                if bb_u in iterations and bb_u == bb_v and pc_bbs[next_pc(u, pcs)] == pc_bbs[u]: # loop
                    weights[bb_u] += (edges[u][v] * iterations[bb_u])
                else:
                    weights[bb_u] += edges[u][v]
            else:
                weights[bb_u] += edges[u][v]

    # Assuming we want to use the first kernel
    # TODO: Address multiple kernels
    with open(f"data/{args.input}.graph", 'w') as fo:
        for node in sorted(cfgs[0]):
            line = f"{node} {weights[node]}"
            for target in sorted(cfgs[0][node]):
                line += f" {target}"
            fo.write(f"{line}\n")