#!/usr/bin/python3

"""\
This script parses the gem5 execution log and HIP assembly file to extract the
CFG of a benchmark.

Usage: extract.py -i <input>

Dependencies:
  <input>.s   : Generated by the HIP compiler using the -save-temps flag
  <input>.log : Generated by gem5 using the WavefrontSplit and IPT debug flags

Output: <input>.graph
"""

# TODO:
#   - Allow runs without log file
#   - Use full input file name
#   - Determine instruction encoding length without log file

import argparse
import glob
import re

from graph import *

class Extractor():
    """
    TODO: Implement a more organized version of the script below.
    """

    smem_inst_pattern = r"^s_((buffer_)?(load|store|)_dword(x[0-9]+)?|" \
        r"atc_probe(_buffer)?|dcache_(inv|wb)(_vol)?|mem(real)?time)"
    ds_inst_pattern = r"^ds_.*"
    vmem_inst_pattern = r"^((t?buffer|image|flat)_.*|export)"
    cond_branch_inst_pattern = r"^s_cbranch_.*"
    uncond_branch_inst_pattern = r"^s_branch.*"
    inst_pattern = r"^(s_|v_|ds_|flat_|t?buffer_|image_|export).*"
    bb_label_pattern = r"^(\;\s*%bb\.[0-9]+|BB[0-9]+_[0-9]+)"
    kernel_start_pattern = r"^\;\s*%bb\.0"
    kernel_end_pattern = r"^s_endpgm.*"

    def __init__(self, input_file) -> None:
        self.input = input_file
        self.kernels = []
        pass

    def read_basic_block_number(self, line: str) -> int:
        """
        Extract the basic block number from the line that defines the basic
        block label
        """
        assert re.search(self.bb_label_pattern, line)
        numbers_in_line = [int(x) for x in re.findall(r'\d+', line)]
        if line.startswith(';'):
            return numbers_in_line[0]
        else:
            return numbers_in_line[1]

    def read_branch_target(self, line: str) -> int:
        """
        Extract the basic block number from the branch instruction target
        """
        assert re.search(self.cond_branch_inst_pattern, line) or \
            re.search(self.uncond_branch_inst_pattern, line)
        numbers_in_line = [int(x) for x in re.findall(r'\d+', line)]
        return numbers_in_line[1]

    def is_double_word_inst(self, line: str) -> bool:
        # FIXME: Identify when using 64-bit vector ALU ops
        return re.search(self.smem_inst_pattern, line) or \
            re.search(self.ds_inst_pattern, line) or \
            re.search(self.vmem_inst_pattern, line)

    def parse_asm(self) -> None:
        """
        Open the assembly file generated with the -save-temps flag and generate
        a CFG of the basic blocks and edges between them
        """
        basic_blocks = {} # TODO: Add a type hint
        weights = {} # TODO: Add a type hint
        starting_pc = {} # TODO: Add a type hint
        insts = {}
        current_bb_number = 0
        pc = 0
        with open(self.input) as fi:
            for line in fi:
                line = line.strip()
                if re.search(self.bb_label_pattern, line):
                    if re.search(self.kernel_start_pattern, line):
                        # Start new kernel
                        basic_blocks[0] = set()
                    else:
                        # Add edge to next block
                        if current_bb_number not in basic_blocks:
                            basic_blocks[current_bb_number] = set()
                        basic_blocks[current_bb_number].add(
                            self.read_basic_block_number(line)
                        )
                    current_bb_number = self.read_basic_block_number(line)
                    starting_pc[current_bb_number] = pc
                elif re.search(self.inst_pattern, line):
                    if re.search(self.cond_branch_inst_pattern, line):
                        # Add edge to branch target block
                        if current_bb_number not in basic_blocks:
                            basic_blocks[current_bb_number] = set()
                        basic_blocks[current_bb_number].add(
                            self.read_branch_target(line)
                        )
                    insts[pc] = line
                    if self.is_double_word_inst(line):
                        pc += 8
                    else:
                        pc += 4
                # FIXME: Doesn't seem to work
                elif re.search(self.kernel_end_pattern, line):
                    self.kernels.append(basic_blocks)
                    basic_blocks = {}
        print("done")

        with open("extractor.txt", 'w+') as fo:
            for pc in sorted(insts):
                fo.write(f"{pc}: {insts[pc]}\n")

    def parse_log(self) -> None:
        """
        Get execution times from gem5 log file and incorporate them as weights
        into the CFG
        """
        pass

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "-i",
            "--input",
            help="Input file name",
            type=str,
            required=True
        )
    parser.add_argument(
            "-l",
            "--log",
            help="Log file name",
            type=str,
            default=''
        )
    args = parser.parse_args()

    e = Extractor(args.input)
    e.parse_asm()